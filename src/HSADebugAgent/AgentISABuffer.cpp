//==============================================================================
// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.
//
/// \author AMD Developer Tools
/// \file
/// \brief Functionality to manage the ISA buffers generated by the finalizer
//==============================================================================
#include <unistd.h>
#include <errno.h>
#include <fstream>
#include <iostream>
#include <cstring>
#include <string>
#include <iomanip>

#include "AgentConfiguration.h"
#include "AgentISABuffer.h"
#include "AgentLogging.h"
#include "AgentNotifyGdb.h"
#include "AgentUtils.h"
#include "CommunicationControl.h"
#include "CommunicationParams.h"
#include "HSADebugAgent.h"

namespace HwDbgAgent
{

AgentISABuffer::~AgentISABuffer()
{
    if (m_pISABufferText != nullptr)
    {
        delete [] m_pISABufferText;
    }
}

AgentISABuffer::AgentISABuffer():
                    m_pISABufferText(NULL),
                    m_ISABufferLen()
{
}

HsailAgentStatus AgentISABuffer::WriteToSharedMem(const int isaBufferShmKey, const size_t isaBufferShmSize) const
{
    HsailAgentStatus status = HSAIL_AGENT_STATUS_FAILURE;

    // Get the pointer to the shmem segment
    void* pShm = AgentMapSharedMemBuffer(isaBufferShmKey, isaBufferShmSize);

    if (pShm == (int*) - 1)
    {
        AGENT_ERROR("WriteBinaryToShmem: Error with AgentMapSharedMemBuffer");
        return status;
    }

    // Clear the memory first
    memset(pShm, 0, isaBufferShmSize);
    // Write the size first
    size_t* pShmSizeLocation = (size_t*)pShm;
    pShmSizeLocation[0] = m_ISABufferLen;

    AGENT_LOG("ISA size: " << pShmSizeLocation[0]);

    if (m_pISABufferText == nullptr)
    {
        AGENT_LOG("No valid ISA buffer present");
        if (m_ISABufferLen != 0)
        {
            AGENT_ERROR("The ISA buffer len is non-zero but the buffer is nullptr");
        }
    }
    else
    {
        // Write the binary after the size_t info
        void* pShmBinaryLocation = (size_t*)pShm + 1;

        if (m_ISABufferLen < isaBufferShmSize )
        {
            // Copy the binary
            memcpy(pShmBinaryLocation, m_pISABufferText, m_ISABufferLen);
        }
        else
        {
            AGENT_WARNING("WriteToSharedMem: ISA Buffer could not be copied to GDB");
            AGENT_WARNING("Binary Size is = " << m_ISABufferLen <<
                          " but shared memory size = " << isaBufferShmSize << "bytes");
        }
    }

    status = AgentUnMapSharedMemBuffer(pShm);

    return status;
}

bool AgentISABuffer::TestForAMDHsaCod()
{
    bool retCode = false;

    if (system (NULL) == 0)
    {
        int noTermErrno = errno;
        AGENT_ERROR("Cannot call system(), errno: " << noTermErrno << ", " << strerror(noTermErrno));
        return retCode;
    }

    const std::string whichAmdhsacod = "which amdhsacod > /dev/null";
    AGENT_LOG("TestForAMDHsaCod: Call " << whichAmdhsacod);

    int ret_value = system(whichAmdhsacod.c_str());
    int err_no = errno;
    AGENT_LOG("TestForAMDHsaCod: Return code: " << retCode << " errno: " << strerror(err_no));

    if (ret_value == 0)
    {
        retCode = true;
    }

    return retCode;
}

HsailAgentStatus  AgentISABuffer::DisassembleAMDHsaCod(const size_t size, const void* codeObj)
{
    HsailAgentStatus status = HSAIL_AGENT_STATUS_FAILURE;

    const std::string amdhsaCodCommand = "amdhsacod -dump -code";
    const std::string codeObjFilename  = "/tmp/codeobj";
    std::string isatextFilename(gs_ISAFileNamePath);

    if (size <= 0 || codeObj == nullptr )
    {
        AGENT_ERROR("DisassembleAMDHsaCod: Invalid input");
        return status;
    }

    status =  AgentWriteBinaryToFile(codeObj, size, codeObjFilename.c_str());
    if (status != HSAIL_AGENT_STATUS_SUCCESS)
    {
        AGENT_ERROR("Could not save the code object to disassemble ISA");
        return status;
    }

    if (!TestForAMDHsaCod())
    {
        AGENT_ERROR("Could not find amdhsacod, kernels cannot be disassembled");
        return status;
    }

    // The command to call amdhsacod is
    // amdhsacod -dump -code CodeObjFileName > IsaFile
    // Using ">" when redirecting will clear the file before writing
    std::stringstream disassembleCommand;
    disassembleCommand << amdhsaCodCommand << " " << codeObjFilename << " > " << isatextFilename;

    AGENT_LOG("DisassembleCodeObject: Call " << disassembleCommand.str());

    int retCode = system(disassembleCommand.str().c_str());
    int err_no = errno;
    AGENT_LOG("DisassembleCodeObject: Return code: " << retCode << "errno: " << strerror(err_no));

    if (retCode != 0)
    {
        AGENT_ERROR("Could not disassemble successfully");
    }

    status = AgentDeleteFile(codeObjFilename.c_str());
    if (status != HSAIL_AGENT_STATUS_SUCCESS)
    {
        AGENT_ERROR("Could not delete " << codeObjFilename);
    }

    return status;
}

HsailAgentStatus AgentISABuffer::PopulateISAFromFile(const std::string& ipFileName)
{
    HsailAgentStatus status = HSAIL_AGENT_STATUS_FAILURE;

    // The input filename is the  ISA file name provided by the finalizer
    if(ipFileName.empty())
    {
        AGENT_ERROR("PopulateISAFromFile: Empty input filename")
        return status;
    }

    std::ifstream ipStream;

    ipStream.open(ipFileName.c_str(), std::ofstream::in);

    if (ipStream.is_open())
    {
        ipStream.seekg(0, ipStream.end);
        m_ISABufferLen = ipStream.tellg();

        AGENT_LOG("ISA buffer size: " << m_ISABufferLen);

        if (m_ISABufferLen > 0)
        {
            m_pISABufferText = new(std::nothrow) char[m_ISABufferLen];
        }

        if (m_pISABufferText == nullptr)
        {
            AGENT_ERROR("Could not allocate a buffer of size " << m_ISABufferLen);
            return status;
        }

        ipStream.seekg(0, ipStream.beg);
        ipStream.read(m_pISABufferText, m_ISABufferLen);

        AGENT_LOG("Save ISA from " << ipFileName);

        ipStream.close();
        status = HSAIL_AGENT_STATUS_SUCCESS;
    }
    else
    {
        AGENT_ERROR("Could not open ISA file " << ipFileName);
    }

    return status;
}

HsailAgentStatus AgentISABuffer::PopulateISAFromCodeObj(const size_t size, const void* codeObj)
{
    // Use amdhsacod
    HsailAgentStatus status = DisassembleAMDHsaCod(size, codeObj);

    return status;
}

bool AgentISABuffer::CheckForKernelName(const std::string& kernelName) const
{
    bool retCode = false;

    std::string pattern = "AMD Kernel Code for " + kernelName+ ":";

    std::string buffer;
    if (m_pISABufferText == nullptr)
    {
        return retCode;
    }
    else
    {
        buffer.assign(m_pISABufferText);
    }

    std::size_t position = buffer.find(pattern);

    if (position != std::string::npos)
    {
        retCode = true;
    }

    AGENT_LOG("Look for pattern \"" << pattern << "\"");

    return retCode;
}

AgentISABufferManager::AgentISABufferManager():
    m_IsaBufferList(),
    m_isaBufferShmKey(-1),
    m_isaBufferShmSize(0)
{
    HsailAgentStatus status = HSAIL_AGENT_STATUS_FAILURE;

    status = GetActiveAgentConfig()->GetConfigShmKey(HSAIL_DEBUG_CONFIG_ISA_BUFFER_SHM, m_isaBufferShmKey);
    if (status != HSAIL_AGENT_STATUS_SUCCESS)
    {
        AGENT_ERROR("Could not get shared mem key");
        return;
    }

    status = GetActiveAgentConfig()->GetConfigShmSize(HSAIL_DEBUG_CONFIG_ISA_BUFFER_SHM, m_isaBufferShmSize);
    if (status != HSAIL_AGENT_STATUS_SUCCESS)
    {
        AGENT_ERROR("Could not get shared mem max size");
        return;
    }

    AgentAllocSharedMemBuffer(m_isaBufferShmKey, m_isaBufferShmSize);
}

// Logic of how the finalizer saves the ISA filename:
//
// File saved as amdhsaXXX.isa,
// Where XXX goes form 000, 001 and so on..
void AgentISABufferManager::GetNextFileName(std::string& outFilename) const
{
    static int callCount = 0;
    ++callCount;

    std::stringstream countSStream;
    countSStream << std::setw(3) << std::setfill('0') << callCount;

    std::stringstream fileNameSStream;
    fileNameSStream << "amdhsa" << countSStream.str() << ".isa";

    outFilename.assign(fileNameSStream.str());
}

// This is called if the ISA is available
// If we have it, we drop it in the shared memory buffer and send it off to GDB.
HsailAgentStatus AgentISABufferManager::FindIsaBufferFromKernelName(const std::string& kernelName, unsigned int& opPosition) const
{
    opPosition = -1;

    for (unsigned int i=0; i< m_IsaBufferList.size(); i++)
    {
        if (m_IsaBufferList.at(i) != nullptr)
        {
            if (m_IsaBufferList.at(i)->CheckForKernelName(kernelName))
            {
                opPosition = i;
                return HSAIL_AGENT_STATUS_SUCCESS;
            }
        }
    }

    return HSAIL_AGENT_STATUS_FAILURE;
}

HsailAgentStatus AgentISABufferManager::AppendISABuffer()
{
    HsailAgentStatus status = HSAIL_AGENT_STATUS_FAILURE;
    std::string fileName;
    GetNextFileName(fileName);

    AgentISABuffer* pIsaBuffer = new(std::nothrow)AgentISABuffer;

    if (pIsaBuffer == nullptr)
    {
        return status;
    }

    status = pIsaBuffer->PopulateISAFromFile(fileName);

    m_IsaBufferList.push_back(pIsaBuffer);

    status = AgentDeleteFile(fileName.c_str());

    return status;
}

AgentISABufferManager::~AgentISABufferManager()
{
    for (unsigned int i=0; i< m_IsaBufferList.size(); i++)
    {
        if (m_IsaBufferList.at(i) != nullptr)
        {
            delete m_IsaBufferList.at(i);
            m_IsaBufferList.at(i) = nullptr;
        }
    }

    m_IsaBufferList.clear();

    AgentFreeSharedMemBuffer(m_isaBufferShmKey, m_isaBufferShmSize);
}

HsailAgentStatus AgentISABufferManager::WriteToSharedMem(const unsigned int isaBufferId) const
{
    HsailAgentStatus status =  HSAIL_AGENT_STATUS_FAILURE;

    if (m_IsaBufferList.size() < isaBufferId)
    {
        AGENT_ERROR("No ISA buffer at position " << isaBufferId);
        return status;
    }

    status =  m_IsaBufferList.at(isaBufferId)->WriteToSharedMem(m_isaBufferShmKey, m_isaBufferShmSize);

    return status;
}

HsailAgentStatus AgentISABufferManager::WriteToSharedMem(const AgentISABuffer& ipISABuffer) const
{
    HsailAgentStatus status =  HSAIL_AGENT_STATUS_FAILURE;

    status =  ipISABuffer.WriteToSharedMem(m_isaBufferShmKey, m_isaBufferShmSize);

    return status;
}


}
